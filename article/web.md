---
title: web前端开发技术
date: 2021-02-31 16:32:11
categories:
  - web
---

## web 前端开发技术的优化策略

网络页面的核心价值在于传递消费者所需要的信息并且以此来满足消费者相应的需求。而对于消费者和体验用户来说，网页加载的快慢直接影响了这个网页的访问量。如果用户在等待网站信息呈现的事件过长，很大程度上会对其消费体验造成一定影响，会造成用户无法将信息进行高效利用。基于这样的考虑，对 web 前端技术进行优化并体现信息的真正价值具有重要的意义。web 前端技术的优化对网络性能的改善、工作效率的提高都发挥着重要作用。可以从以下几个方面开展工作，对 web 前端技术进行优化：

1. 减少 HTTP 请求数
   减少不必要的消耗时间的 Http 请求数，是 web 前端开发技术的一个重要方面。一个完整的 Http 包括 DNS 寻址、发送双方的数据、建立浏览器和服务器间的连接并传输数据、等待服务器响应等等多个环节。在这个过程中，每一个 Http 请求都必须携带数据，因此每一个请求都不免占用宽带资源，导致用户等待时间增加。要减少网页中 Http 的请求，经常被采用的方法有：将多个 CSS 文件或者 JavaScript 文件合并成一个；优化图片地图，在一个图像上划分不同区域以及注入不通过映射的链接；保持图片和文本一起显示和下载；通过利用 CSS background 进行背景图的绝对定位，这种做法可以提高网页的载入速度，提高用户的体验。

2. 优化文件的规模
   文件规模能对网页加载造成一定的影响 ，这个过程包括压缩 JavaScript 和 CSS 文件以及对相应的代码进行优化。优化代码的工作主要是删除一些不必要的 Html 标签，避免内联式和优化 CSS 代码。

3. 减少 DNS 查找
   DNS 查找的时间开销很大，这是国内许多网站的通病。在一次 DNS 的解析过程中会耗费 20~120ms，若 DNS 解析请求过于频繁，就会导致用户等待时间的增加，同时也会使信息传输的质量有所下降。并且在 DNS 查找结束前，浏览器将无法下载该域名下的任何东西。对于国内的站点来说，过多使用站外的 Widget（微件），也易引起 DNS 查找过多的问题。适当减少 DNS 查找能有效地提高网页地加载速度，对于 web 前端开发技术来说，DNS 查找的优化也非常重要。

4. 杜绝无用响应
   在用户访问网站的时候，常常会遇到无用响应，如 404 错误或拒绝访问错误，这是没有找到文件引起的。Http 请求耗费时间过长，而较长的等待时间却得到一个无用的响应页面，大大降低了用户体验。对页面的链接进行充分的测试加上对 web 服务器 Errorr 日志的不断跟踪能有效地减少 404 错误。大多时候，这种错误由于定位稍难而容易被技术人员忽略。

5. 有效避免重定向
   网页的重定向会耗费一定的时间，这也是造成用户等待时间过长的一个因素。重定向问题的产生有很多，每增加一次重定向就必然会增加一次对 web 的请求，所以重定向问题应该尽量避免。这要求技术人员能对 web 站点的子目录后加一个"/"，这种做法能有效避免重定向。

6. 优化网页内容
   CSS 的全称是层叠样式表，层叠表明后面的 CSS 可以覆盖前面的，高级的可以覆盖低级的，因此浏览器会在完全加载完后才考虑开展渲染工作。根据 CSS 这样的特性，要实现 web 的优化，可以考虑将样式表放在顶部。另外，可以将 script 放在底部，该举措是为了防止 script 脚本阻塞当前页面，从而造成下载速度较慢，页面的加载时间过长等问题的产生。

## Web 实时推送技术

### 一、双向通信

HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。在 WebSocket 协议之前，有三种实现双向通信的方式：轮询（polling）、长轮询（long-polling）和 iframe 流（streaming）。

1. 轮询（polling）
   轮询是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次。其缺点也很明显：连接数会很多，一个接受，一个发送。而且每次发送请求都会有 Http 的 Header，会很耗流量，也会消耗 CPU 的利用率。

- 优点：实现简单，无需做过多的更改
- 缺点：轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担

2. 长轮询（long-polling）

长轮询是对轮询的改进版，客户端发送 HTTP 给服务器之后，看有没有新消息，如果没有新消息，就一直等待。当有新消息的时候，才会返回给客户端。在某种程度上减小了网络带宽和 CPU 利用率等问题。由于 http 数据包的头部数据量往往很大（通常有 400 多个字节），但是真正被服务器需要的数据却很少（有时只有 10 个字节左右），这样的数据包在网络上周期性的传输，难免对网络带宽是一种浪费。

- 优点：比 Polling 做了优化，有较好的时效性
- 缺点：保持连接会消耗资源; 服务器没有返回有效数据，程序超时。

3. iframe 流（streaming）
   iframe 流方式是在页面中插入一个隐藏的 iframe，利用其 src 属性在服务器和客户端之间创建一条长连接，服务器向 iframe 传输数据（通常是 HTML，内有负责插入信息的 javascript），来实时更新页面。

- 优点：消息能够实时到达；浏览器兼容好
- 缺点：服务器维护一个长连接会增加开销；IE、chrome、Firefox 会显示加载没有完成，图标会不停旋转。

### 二、WebSocket

1. 什么是 websocket
   WebSocket 是一种全新的协议，随着 HTML5 草案的不断完善，越来越多的现代浏览器开始全面支持 WebSocket 技术了，它将 TCP 的 Socket（套接字）应用在了 webpage 上，从而使通信双方建立起一个保持在活动状态连接通道。

一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。

初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？

2. HTTP 的局限性
   HTTP 是半双工协议，也就是说，在同一时刻数据只能单向流动，客户端向服务器发送请求(单向的)，然后服务器响应请求(单向的)。
   服务器不能主动推送数据给浏览器。这就会导致一些高级功能难以实现，诸如聊天室场景就没法实现。
3. WebSocket 的特点
   支持双向通信，实时性更强
   可以发送文本，也可以发送二进制数据
   减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了相对于传统的 HTTP 每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket 是类似 Socket 的 TCP 长连接的通讯模式，一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。在客户端断开 WebSocket 连接或 Server 端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。

### 三、Web 实时推送技术的比较

方式类型技术实现优点缺点适用场景

- 轮询 Pollingclient→server 客户端循环请求
  1、实现简单
  2、 支持跨域
  1、浪费带宽和服务器资源
  2、 一次请求信息大半是无用（完整 http 头信息）
  3、有延迟
  4、大部分无效请求适于小型应用
- 长轮询 Long-Pollingclient→server 服务器 hold 住连接，一直到有数据或者超时才返回，减少重复请求次数
  1、实现简单
  2、不会频繁发请求
  3、节省流量
  4、延迟低
  1、服务器 hold 住连接，会消耗资源
  2、一次请求信息大半是无用 WebQQ、Hi 网页版、Facebook
- IM 长连接 iframeclient→server 在页面里嵌入一个隐蔵 iframe，将这个 iframe 的 src 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。
  1、数据实时送达
  2、不发无用请求，一次链接，多次“推送”
  1、服务器增加开销
  2、无法准确知道连接状态
  3、IE、chrome 等一直会处于 loading 状态 Gmail 聊天
- WebSocketserver⇌clientnew WebSocket()
  1、支持双向通信，实时性更强
  2、可发送二进制文件
  3、减少通信量
  1、浏览器支持程度不一致
  2、不支持断开重连网络游戏、银行交互和支付

## 缓存

> 首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，避免重新向服务器发起资源请求。
> 减少冗余数据传输，节省网络流量，减轻服务器压力，加快访问速度

### 强制缓存

不会向服务器发请求，而是直接从缓存中读取资源，在控制台中返回`200`状态码

响应头参数

- `pragma`:`no-cache`;兼容 http 1.0
- `Expires`:兼容 http 1.0,响应头里的过期时间，若在这个时间内，则命中强缓存；（以分钟为单位，在服务端配置，当客户端和服务端时间不一致的时候会出现问题，优先级比`Cache-Control`低）
- `Cache-Control`:只兼容 http 1.1。是在服务器端配置的,
  - 当值为`max-age=300`时（以秒为单位），则代表这个请求正确返回时间的五分钟内再次加载资源，就会命中强缓存。等于 0 则不使用缓存
  - 当为-`no-cache`时，表示不使用强缓存，需要使用协商缓存，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 Etag，那么请求时会与服务端验证，如果资源未被更改，则可避免重复下载。
  - 当为-`no-store`时，表示直接禁止浏览器缓存数据。
  - 当为-`public`时，表示被所有的用户缓存，包括终端用户和 cdn 等中间代理服务器。
  - 当为-`private`时，表示只能被终端用户缓存，不允许 cdn 等中继服务器对其缓存。

### 协商缓存

在使用本地缓存前，需向服务器发送请求，服务器根据请求头的参数判断是否命中协商缓存，若命中，则返回`304`状态码并带上新的响应头通知浏览器从缓存中读取数据。协商缓存可以解决本地资源不更新的问题。

需设置`Cache-Control`为`no-cache`

- `Last-Modify`:浏览器第一次请求一个资源时，服务器返回的响应头会加上`Last-Modify`，其为一个时间标识，记录该资源最后修改的时间.
- `If-Modify-Since`:当浏览器再次请求同一个资源时，请求头会包含`If-Modify-Sine`，值为缓存之前返回的`Last—Modify`。服务器收到后根据当前资源修改的 时间判断是否命中缓存

- `Etag`:浏览器第一次请求一个资源时，服务器返回当前资源在服务器的唯一标识
- `If-None-Match`:再次请求时，若发现资源有 Etag 声明，则请求头会带上`If-None-Match`,值为`Etag`的值，服务器收到后进行比较来判断是否命中缓存。

区别

- 优先级上，`etag/if-none-match`更高
- 精度上`etag`要优于`last-modify`，`last-modify`单位为 s，使用它无法区分一秒内修改多次的情况。
- 性能上`etag`要逊于`last-modify`，`etag`需要服务器额外性能计算 hash 值。

> ctrl+r/f5/地址栏刷新：强缓存和协商缓存都生效
> ctrl+f5/ctrl+shift+r:全部失效，会重新请求资源并缓存
> post 请求无法被缓存

静态页面可通过配置 meta 标签设置缓存属性

```html
<meta http-equiv="Cache-Control" content="max-age=3000" />
```

## 从输入 url 到页面完成加载发生了什么

- DNS 解析：将域名解析成 IP 地址
  DNS(domain name system，域名系统)：因特网上域名和 IP 地址相互映射的分布式数据库；简单理解就是域名与 IP 地址的对照表
  URL(Uniform Resource Locator)，统一资源定位符，用于定位互联网上资源，俗称网址。
  遵守以下的语法规则：
  `scheme://host.domain:port/path/filename`

- TCP 连接：TCP 三次握手
  第一次握手，由浏览器发起，告诉服务器我要发送请求了；
  第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧。
  第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧。
  “三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。
- 发送 HTTP 请求

HTTP 请求报文格式：`请求行`+`请求头`+`空行`+`消息体`，请求行包括请求方式(GET/POST/DELETE/PUT)、请求资源路径(URL)、HTTP 版本号；

- 服务器处理请求并返回 HTTP 报文

服务器收到请求后会发出应答，即响应数据。HTTP 响应与 HTTP 请求相似， HTTP 响应报文格式：`状态行`+`响应头`+`空行`+`消息体`，状态行包括 HTTP 版本号、状态码、状态说明。

- 浏览器解析渲染页面
  浏览器拿到响应文本后，解析 HTML 代码，请求 js，css 等资源，最后进行页面渲染，呈现给用户。页面渲染一般分为以下几个步骤：

(1)根据 HTML 文件解析出 DOM Tree

(2)根据 CSS 解析出 CSSOM Tree(CSS 规则树)

(3)将 DOM Tree 和 CSSOM Tree 合并，构建 Render tree(渲染树)

(4)reflow(重排)：根据 Render tree 进行节点信息计算(Layout)

(5)repaint(重绘)：根据计算好的信息绘制整个页面(Painting)

- 连接结束：TCP 四次挥手

```txt
1、A——>B ：A告诉B：“我发完了”；

2、B——>A：B告诉A：“好的，我知道你发完了”

3、B——>A：B告诉A：“我收完了”；

4、A——>B：A告诉B：“好的，我知道你发收完了”
```

## 重绘 和 重排（回流）

> 重绘不一定导致重排，但重排一定会导致重绘
> 重排（Reflow） && 重绘（Redraw）会付出高昂的性能代价

### 重绘

重绘 （Redraw）：某些元素的外观被改变所触发的浏览器行为（重新计算节点在屏幕中的绝对位置并渲染的过程）； 例如：修改元素的填充颜色，会触发重绘；

下面情况会发生重绘：

- color
- border-style
- border-radius
- text-decoration
- box-shadow
- outline
- background
- ...

### 重排（回流）

重排 （Reflow）：重新生成布局，重新排列元素（重新计算各节点和 css 具体的大小和位置：渲染树需要重新计算所有受影响的节点）；例如：改元素的宽高，会触发重排；
通过两者概念区别明显得知，重排要比重绘的成本大得多，我们应该尽量减少重排操作，减少页面性能消耗

- 页面初始渲染，这是开销最大的一次重排;
- 添加/删除可见的 DOM 元素;
- 改变`元素位置`;
- 改变`元素尺寸`，比如边距、填充、边框、宽度和高度等;
- 改变`元素内容`，比如文字数量，图片大小等;
- 改变元素`字体大小`;
- 改变浏览器窗口尺寸，比如 resize 事件发生时;
- 激活`CSS伪类`（例如：:hover）;
- 设置 `style 属性`的值，因为通过设置 style 属性改变结点样式的话，每一次设置都会触发一次 reflow;
- 查询某些属性或调用某些计算方法：`offsetWidth`、`offsetHeigh`t 等，除此之外，当我们调用 getComputedStyl 方法，或者 IE 里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”;

```txt
width height margin padding
display border-width border position
overflow font-size vertical-align min-height
clientWidth clientHeight clientTop clientLeft
offsetWidth offsetHeight offsetTop offsetLeft
scrollWidth scrollHeight scrollTop scrollLeft
scrollIntoView() scrollTo() getComputedStyle()
getBoundingClientRect() scrollIntoViewIfNeeded()
```

### 减少重排次数

- 样式集中改变
  不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的 className。
- 分离读写操作
  DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作
- 将 DOM 离线
  使用 display:none

- 使用 absolute 或 fixed 脱离文档流
  为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。

## script 标签中 defer 和 async 的区别

多个带 async 属性的标签，不能保证加载的顺序；多个带 defer 属性的标签，按照加载顺序执行;

- async 属性，表示后续文档的加载和执行与 js 脚本的加载和执行是并行进行的，即异步执行；
- defer 属性，加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是并行进行的(异步)，js 脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded 事件触发执行之前。

## 前端路由

前端路由是指在浏览器端控制页面内容切换显示的机制。在没有服务器端参与的情况下，前端路由可以根据 URL 的变化，对应展现不同的内容，实现页面的“伪”跳转。在现代前端开发中，单页面应用（SPA）已成为一种常见的架构风格。与传统的多页面应用（MPA）相比，SPA 能够提供更加流畅的用户体验，因为它无需重新加载整个页面即可更新部分页面内容。

### 路由的基本模式

- Hash 模式原理：
  - 浏览器原生支持通过 window.location.hash 读写 URL 中的 hash 值，并且当 hash 值变化时，页面不会触发重新加载。
  - SPA 可以监听 hashchange 事件，在 URL 的 hash 部分变化时根据定义好的路由映射关系来动态渲染内容。

```js
// Hash模式的简易实现
window.addEventListener("hashchange", routeChange);
function routeChange() {
  const hash = window.location.hash.slice(1); // Remove the '#' symbol
  // 基于hash值显示不同内容
  routerView.innerHTML = routes[hash] ? routes[hash] : routes["404"];
}
```

- History 模式原理：
  - History API 允许 SPA 在浏览历史记录中添加、修改记录而不会触发页面加载。
  - 通过 history.pushState 和 history.replaceState 可以改变 URL 且不重新加载页面。
  - SPA 可以监听 popstate 事件来响应浏览器前进、后退操作。

```js
// History模式的简易实现
window.addEventListener("popstate", routeChange);
function navigate(path) {
  history.pushState({}, "", path);
  routeChange();
}
function routeChange() {
  const path = window.location.pathname;
  // 根据pathname来渲染不同的页面组件
  routerView.innerHTML = routes[path] ? routes[path] : routes["404"];
}

// navigate('/user'); // 导航至用户页面
```

### 前端路由的实现

在实际项目中，前端路由通常借助专业的路由库（如 react-router、vue-router 等）来实现。而且，需要考虑到如下两个常见问题的解决方案：

- 路由懒加载：

为了加快首次页面加载速度，可以将不同路由对应的组件分割成独立的代码块后懒加载，仅当路由被访问时才加载对应组件。

- 路由的保护与权限控制：

前端路由守卫提供了在路由跳转执行前后插入逻辑的能力，可用于权限验证、数据预加载、动画过渡等。

1. 使用路由导航钩子控制跳转流程，如进行权限校验。
2. 结合状态管理和路由，在状态改变时同步 URL 变化，确保用户随时刷新页面或分享链接都能获得一致的界面状态。
3. 利用`<link rel="prefetch">`或`import(/* webpackPrefetch: true */ './path/to/Component')`进行资源预获取，提高路由跳转的性能。
