---
title: web前端开发技术
date: 2021-02-31 16:32:11
categories:
- web
---

## web前端开发技术的优化策略

网络页面的核心价值在于传递消费者所需要的信息并且以此来满足消费者相应的需求。而对于消费者和体验用户来说，网页加载的快慢直接影响了这个网页的访问量。如果用户在等待网站信息呈现的事件过长，很大程度上会对其消费体验造成一定影响，会造成用户无法将信息进行高效利用。基于这样的考虑，对web前端技术进行优化并体现信息的真正价值具有重要的意义。web前端技术的优化对网络性能的改善、工作效率的提高都发挥着重要作用。可以从以下几个方面开展工作，对web前端技术进行优化：

1. 减少HTTP请求数
减少不必要的消耗时间的Http请求数，是web前端开发技术的一个重要方面。一个完整的Http包括DNS寻址、发送双方的数据、建立浏览器和服务器间的连接并传输数据、等待服务器响应等等多个环节。在这个过程中，每一个Http请求都必须携带数据，因此每一个请求都不免占用宽带资源，导致用户等待时间增加。要减少网页中Http的请求，经常被采用的方法有：将多个CSS文件或者JavaScript文件合并成一个；优化图片地图，在一个图像上划分不同区域以及注入不通过映射的链接；保持图片和文本一起显示和下载；通过利用CSS background进行背景图的绝对定位，这种做法可以提高网页的载入速度，提高用户的体验。

2. 优化文件的规模
文件规模能对网页加载造成一定的影响 ，这个过程包括压缩JavaScript和CSS文件以及对相应的代码进行优化。优化代码的工作主要是删除一些不必要的Html标签，避免内联式和优化CSS代码。

3. 减少DNS查找
DNS查找的时间开销很大，这是国内许多网站的通病。在一次DNS的解析过程中会耗费20~120ms，若DNS解析请求过于频繁，就会导致用户等待时间的增加，同时也会使信息传输的质量有所下降。并且在DNS查找结束前，浏览器将无法下载该域名下的任何东西。对于国内的站点来说，过多使用站外的Widget（微件），也易引起DNS查找过多的问题。适当减少DNS查找能有效地提高网页地加载速度，对于web前端开发技术来说，DNS查找的优化也非常重要。

4. 杜绝无用响应
在用户访问网站的时候，常常会遇到无用响应，如404错误或拒绝访问错误，这是没有找到文件引起的。Http请求耗费时间过长，而较长的等待时间却得到一个无用的响应页面，大大降低了用户体验。对页面的链接进行充分的测试加上对web服务器Errorr日志的不断跟踪能有效地减少404错误。大多时候，这种错误由于定位稍难而容易被技术人员忽略。

5. 有效避免重定向
网页的重定向会耗费一定的时间，这也是造成用户等待时间过长的一个因素。重定向问题的产生有很多，每增加一次重定向就必然会增加一次对web的请求，所以重定向问题应该尽量避免。这要求技术人员能对web站点的子目录后加一个"/"，这种做法能有效避免重定向。

6. 优化网页内容
CSS的全称是层叠样式表，层叠表明后面的CSS可以覆盖前面的，高级的可以覆盖低级的，因此浏览器会在完全加载完后才考虑开展渲染工作。根据CSS这样的特性，要实现web的优化，可以考虑将样式表放在顶部。另外，可以将script放在底部，该举措是为了防止script脚本阻塞当前页面，从而造成下载速度较慢，页面的加载时间过长等问题的产生。

## Web 实时推送技术

### 一、双向通信

HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。在WebSocket协议之前，有三种实现双向通信的方式：轮询（polling）、长轮询（long-polling）和iframe流（streaming）。

1. 轮询（polling）
轮询是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次。其缺点也很明显：连接数会很多，一个接受，一个发送。而且每次发送请求都会有Http的Header，会很耗流量，也会消耗CPU的利用率。

- 优点：实现简单，无需做过多的更改
- 缺点：轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担

2. 长轮询（long-polling）

长轮询是对轮询的改进版，客户端发送HTTP给服务器之后，看有没有新消息，如果没有新消息，就一直等待。当有新消息的时候，才会返回给客户端。在某种程度上减小了网络带宽和CPU利用率等问题。由于http数据包的头部数据量往往很大（通常有400多个字节），但是真正被服务器需要的数据却很少（有时只有10个字节左右），这样的数据包在网络上周期性的传输，难免对网络带宽是一种浪费。

- 优点：比 Polling 做了优化，有较好的时效性
- 缺点：保持连接会消耗资源; 服务器没有返回有效数据，程序超时。

3. iframe流（streaming）
iframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长连接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。

- 优点：消息能够实时到达；浏览器兼容好
- 缺点：服务器维护一个长连接会增加开销；IE、chrome、Firefox会显示加载没有完成，图标会不停旋转。

### 二、WebSocket

1. 什么是websocket
WebSocket是一种全新的协议，随着HTML5草案的不断完善，越来越多的现代浏览器开始全面支持WebSocket技术了，它将TCP的Socket（套接字）应用在了webpage上，从而使通信双方建立起一个保持在活动状态连接通道。

一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。

初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？

2. HTTP的局限性
HTTP是半双工协议，也就是说，在同一时刻数据只能单向流动，客户端向服务器发送请求(单向的)，然后服务器响应请求(单向的)。
服务器不能主动推送数据给浏览器。这就会导致一些高级功能难以实现，诸如聊天室场景就没法实现。
3. WebSocket的特点
支持双向通信，实时性更强
可以发送文本，也可以发送二进制数据
减少通信量：只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了相对于传统的HTTP每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接的通讯模式，一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。

### 三、Web 实时推送技术的比较

方式类型技术实现优点缺点适用场景

- 轮询Pollingclient→server客户端循环请求
1、实现简单
2、 支持跨域
1、浪费带宽和服务器资源
2、 一次请求信息大半是无用（完整http头信息）
3、有延迟
4、大部分无效请求适于小型应用
- 长轮询Long-Pollingclient→server服务器hold住连接，一直到有数据或者超时才返回，减少重复请求次数
1、实现简单
2、不会频繁发请求
3、节省流量
4、延迟低
1、服务器hold住连接，会消耗资源
2、一次请求信息大半是无用WebQQ、Hi网页版、Facebook
- IM长连接iframeclient→server在页面里嵌入一个隐蔵iframe，将这个 iframe 的 src 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。
1、数据实时送达
2、不发无用请求，一次链接，多次“推送”
1、服务器增加开销
2、无法准确知道连接状态
3、IE、chrome等一直会处于loading状态Gmail聊天
- WebSocketserver⇌clientnew WebSocket()
1、支持双向通信，实时性更强
2、可发送二进制文件
3、减少通信量
1、浏览器支持程度不一致
2、不支持断开重连网络游戏、银行交互和支付

## 缓存

>首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，避免重新向服务器发起资源请求。
>减少冗余数据传输，节省网络流量，减轻服务器压力，加快访问速度

### 强制缓存

不会向服务器发请求，而是直接从缓存中读取资源，在控制台中返回`200`状态码

响应头参数

- `pragma`:`no-cache`;兼容http 1.0
- `Expires`:兼容http 1.0,响应头里的过期时间，若在这个时间内，则命中强缓存；（以分钟为单位，在服务端配置，当客户端和服务端时间不一致的时候会出现问题，优先级比`Cache-Control`低）
- `Cache-Control`:只兼容http 1.1。是在服务器端配置的,
  - 当值为`max-age=300`时（以秒为单位），则代表这个请求正确返回时间的五分钟内再次加载资源，就会命中强缓存。等于0则不使用缓存
  - 当为-`no-cache`时，表示不使用强缓存，需要使用协商缓存，先与服务器确认返回的响应是否被更改，如果之前的响应中存在Etag，那么请求时会与服务端验证，如果资源未被更改，则可避免重复下载。
  - 当为-`no-store`时，表示直接禁止浏览器缓存数据。
  - 当为-`public`时，表示被所有的用户缓存，包括终端用户和cdn等中间代理服务器。
  - 当为-`private`时，表示只能被终端用户缓存，不允许cdn等中继服务器对其缓存。

### 协商缓存

在使用本地缓存前，需向服务器发送请求，服务器根据请求头的参数判断是否命中协商缓存，若命中，则返回`304`状态码并带上新的响应头通知浏览器从缓存中读取数据。协商缓存可以解决本地资源不更新的问题。

需设置`Cache-Control`为`no-cache`

- `Last-Modify`:浏览器第一次请求一个资源时，服务器返回的响应头会加上`Last-Modify`，其为一个时间标识，记录该资源最后修改的时间.
- `If-Modify-Since`:当浏览器再次请求同一个资源时，请求头会包含`If-Modify-Sine`，值为缓存之前返回的`Last—Modify`。服务器收到后根据当前资源修改的 时间判断是否命中缓存

- `Etag`:浏览器第一次请求一个资源时，服务器返回当前资源在服务器的唯一标识
- `If-None-Match`:再次请求时，若发现资源有Etag声明，则请求头会带上`If-None-Match`,值为`Etag`的值，服务器收到后进行比较来判断是否命中缓存。

区别

- 优先级上，`etag/if-none-match`更高
- 精度上`etag`要优于`last-modify`，`last-modify`单位为s，使用它无法区分一秒内修改多次的情况。
- 性能上`etag`要逊于`last-modify`，`etag`需要服务器额外性能计算hash值。

>ctrl+r/f5/地址栏刷新：强缓存和协商缓存都生效
>ctrl+f5/ctrl+shift+r:全部失效，会重新请求资源并缓存
>post请求无法被缓存

静态页面可通过配置meta标签设置缓存属性

```html
<meta http-equiv="Cache-Control" content="max-age=3000"/>
```

## 从输入url到页面完成加载发生了什么

- DNS解析：将域名解析成IP地址
DNS(domain name system，域名系统)：因特网上域名和IP地址相互映射的分布式数据库；简单理解就是域名与IP地址的对照表
URL(Uniform Resource Locator)，统一资源定位符，用于定位互联网上资源，俗称网址。
遵守以下的语法规则：
`scheme://host.domain:port/path/filename`

- TCP连接：TCP三次握手
第一次握手，由浏览器发起，告诉服务器我要发送请求了；
第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧。
第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧。
“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。
- 发送HTTP请求

HTTP请求报文格式：`请求行`+`请求头`+`空行`+`消息体`，请求行包括请求方式(GET/POST/DELETE/PUT)、请求资源路径(URL)、HTTP版本号；

- 服务器处理请求并返回HTTP报文

服务器收到请求后会发出应答，即响应数据。HTTP响应与HTTP请求相似， HTTP响应报文格式：`状态行`+`响应头`+`空行`+`消息体`，状态行包括HTTP版本号、状态码、状态说明。

- 浏览器解析渲染页面
浏览器拿到响应文本后，解析HTML代码，请求js，css等资源，最后进行页面渲染，呈现给用户。页面渲染一般分为以下几个步骤：

(1)根据HTML文件解析出DOM Tree

(2)根据CSS解析出 CSSOM Tree(CSS规则树)

(3)将 DOM Tree 和 CSSOM Tree合并，构建Render tree(渲染树)

(4)reflow(重排)：根据Render tree进行节点信息计算(Layout)

(5)repaint(重绘)：根据计算好的信息绘制整个页面(Painting)

- 连接结束：TCP四次挥手

```txt
1、A——>B ：A告诉B：“我发完了”；

2、B——>A：B告诉A：“好的，我知道你发完了”

3、B——>A：B告诉A：“我收完了”；

4、A——>B：A告诉B：“好的，我知道你发收完了”
```

## 重绘 和 重排（回流）
>
>重绘不一定导致重排，但重排一定会导致重绘
> 重排（Reflow） && 重绘（Redraw）会付出高昂的性能代价

### 重绘

重绘 （Redraw）：某些元素的外观被改变所触发的浏览器行为（重新计算节点在屏幕中的绝对位置并渲染的过程）； 例如：修改元素的填充颜色，会触发重绘；

下面情况会发生重绘：

- color
- border-style
- border-radius
- text-decoration
- box-shadow
- outline
- background
- ...

### 重排（回流）

重排 （Reflow）：重新生成布局，重新排列元素（重新计算各节点和css具体的大小和位置：渲染树需要重新计算所有受影响的节点）；例如：改元素的宽高，会触发重排；
通过两者概念区别明显得知，重排要比重绘的成本大得多，我们应该尽量减少重排操作，减少页面性能消耗

- 页面初始渲染，这是开销最大的一次重排;
- 添加/删除可见的DOM元素;
- 改变`元素位置`;
- 改变`元素尺寸`，比如边距、填充、边框、宽度和高度等;
- 改变`元素内容`，比如文字数量，图片大小等;
- 改变元素`字体大小`;
- 改变浏览器窗口尺寸，比如resize事件发生时;
- 激活`CSS伪类`（例如：:hover）;
- 设置 `style 属性`的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow;
- 查询某些属性或调用某些计算方法：`offsetWidth`、`offsetHeigh`t等，除此之外，当我们调用getComputedStyl方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”;

```txt
width height margin padding
display border-width border position
overflow font-size vertical-align min-height
clientWidth clientHeight clientTop clientLeft
offsetWidth offsetHeight offsetTop offsetLeft
scrollWidth scrollHeight scrollTop scrollLeft
scrollIntoView() scrollTo() getComputedStyle() 
getBoundingClientRect() scrollIntoViewIfNeeded() 
```

### 减少重排次数

- 样式集中改变
不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的 className。
- 分离读写操作
DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作
- 将 DOM 离线
使用 display:none

- 使用 absolute 或 fixed 脱离文档流
为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。

## script标签中defer和async的区别

多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行;

- async属性，表示后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；
- defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。

## 前端路由

前端路由是指在浏览器端控制页面内容切换显示的机制。在没有服务器端参与的情况下，前端路由可以根据URL的变化，对应展现不同的内容，实现页面的“伪”跳转。在现代前端开发中，单页面应用（SPA）已成为一种常见的架构风格。与传统的多页面应用（MPA）相比，SPA能够提供更加流畅的用户体验，因为它无需重新加载整个页面即可更新部分页面内容。

### 路由的基本模式

- Hash模式原理：
  - 浏览器原生支持通过window.location.hash读写URL中的hash值，并且当hash值变化时，页面不会触发重新加载。
  - SPA可以监听hashchange事件，在URL的hash部分变化时根据定义好的路由映射关系来动态渲染内容。

```js
// Hash模式的简易实现
window.addEventListener('hashchange', routeChange);
function routeChange() {
  const hash = window.location.hash.slice(1); // Remove the '#' symbol
  // 基于hash值显示不同内容
  routerView.innerHTML = routes[hash] ? routes[hash] : routes['404'];
}
```

- History模式原理：
  - History API 允许SPA在浏览历史记录中添加、修改记录而不会触发页面加载。
  - 通过history.pushState和history.replaceState可以改变URL且不重新加载页面。
  - SPA可以监听popstate事件来响应浏览器前进、后退操作。

```js
// History模式的简易实现
window.addEventListener('popstate', routeChange);
function navigate(path) {
  history.pushState({}, "", path);
  routeChange();
}
function routeChange() {
  const path = window.location.pathname;
  // 根据pathname来渲染不同的页面组件
  routerView.innerHTML = routes[path] ? routes[path] : routes['404'];
}

// navigate('/user'); // 导航至用户页面
```

### 前端路由的实现

在实际项目中，前端路由通常借助专业的路由库（如react-router、vue-router等）来实现。而且，需要考虑到如下两个常见问题的解决方案：

- 路由懒加载：

为了加快首次页面加载速度，可以将不同路由对应的组件分割成独立的代码块后懒加载，仅当路由被访问时才加载对应组件。

- 路由的保护与权限控制：

前端路由守卫提供了在路由跳转执行前后插入逻辑的能力，可用于权限验证、数据预加载、动画过渡等。

1. 使用路由导航钩子控制跳转流程，如进行权限校验。
2. 结合状态管理和路由，在状态改变时同步URL变化，确保用户随时刷新页面或分享链接都能获得一致的界面状态。
3. 利用`<link rel="prefetch">`或`import(/* webpackPrefetch: true */ './path/to/Component')`进行资源预获取，提高路由跳转的性能。
